<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>현재 밀집도</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" rel="stylesheet" type="text/css">
    <link href="/static/css/index.css" rel="stylesheet">
    
</head>
<body onload="initTmap();">
    
    <div class="app-container">
        <div class="header">
            <h5 id="loc_main" class="loc_main mb-0">서울특별시</h5>
        </div>
        <div class="content">
            <p id="density_title" class="mb-1 mt-2">현재 밀집도</p>
            <p id="density_val" class="mb-0">50%</p>
            <p id="density_stage" class="status mt-0"></p>
            <p id="server_date" class="date_time mb-1"></p>
            <p id="server_time" class="date_time mb-3"></p>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <script src="/static/js/jihoon.js"></script>
    <script src="/static/js/hamin.js"></script>
    <script>
        const key = h_config.apikey;
        // const key = j_config.apikey;

        $.getScript('https://apis.openapi.sk.com/tmap/jsv2?version=1&appKey='+key, function() {
            console.log('로드 완료');
        }).fail(function(jqxhr, settings, exception) {
            console.error('TMap JavaScript API 로드 실패', exception);
        });
        

        // 페이지가 로딩이 된 후 호출하는 함수입니다.
        function initTmap() {
            getCurrentLocation();
        }

        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(showCurrentLocation, locationError);
            } else {
                alert("위치 정보를 지원하지 않는 기종입니다.");
            }
        }

        function showCurrentLocation(position) {
            const currentLat = position.coords.latitude;
            const currentLon = position.coords.longitude;
            
            console.log("Current Location: " + currentLat + ", " + currentLon);

            reverseLabel(currentLon, currentLat);
        }

        function locationError(error) {
            console.warn(`ERROR(${error.code}): ${error.message}`);
        }

        function reverseLabel(currentLon, currentLat) {
            $.ajax({
                method: "GET",
                url: "https://apis.openapi.sk.com/tmap/geo/reverseLabel?version=1&format=json",
                data: {
                    "reqLevel": 15,
                    "centerLon": currentLon,
                    "centerLat": currentLat,
                    "reqCoordType": "WGS84GEO",
                    "resCoordType": "WGS84GEO",
                    "appKey": key
                },
                success: function(response) {
                    const resultInfo = response.poiInfo;
                    if (resultInfo) {
                        const { poiLon: lon, poiLat: lat, id: poiId, name } = resultInfo;
                        const url = `https://apis.openapi.sk.com/tmap/puzzle/pois/${poiId}?format=json&appKey=${key}&lat=${currentLat}&lng=${currentLon}`;
                        puzzle(url, name);
                    } else {
                        console.log("위치 정보를 찾을 수 없습니다.");
                    }
                },
                error: function(request, status, error) {
                    console.log("code:" + request.status + "\nmessage:" + request.responseText + "\nerror:" + error);
                }
            });
        }

        function puzzle(url, name) {
            $.ajax({
                method: "GET",
                url: url,
                success: function(response) {
                    console.log(response);
                    
                    const parts = response.contents.poiName;

                    // 첫 번째 요소는 건물 이름이므로 공백을 제거하고 출력
                    const buildingName = parts;

                    const rltm = response.contents.rltm;
                    
                    if (rltm && rltm.length > 0) {
                        const data = rltm.find(item => item.type === 2);
                        if (data) {
                            const { congestion, congestionLevel, datetime } = data;
                            const congestText = congestionLevelText(congestionLevel);
                            const congestionPercentage = (Number(congestion) * 100).toFixed(2);
                            const dateStr = formatDate(datetime);
                            
                            // 년, 월, 일 추출
                            let year = datetime.substr(0, 4);
                            let month = datetime.substr(4, 2);
                            let day = datetime.substr(6, 2);

                            // 시간, 분 추출 및 형식 변환
                            let hour = parseInt(datetime.substr(8, 2));
                            let min = datetime.substr(10, 2);
                            let period = "AM";

                            if (hour >= 12) {
                                period = "PM";
                                if (hour > 12) {
                                    hour -= 12;
                                }
                            } else if (hour === 0) {
                                hour = 12;
                            }

                            // 숫자를 문자열로 변환하고 앞에 0을 붙여 2자리 형식으로 맞춤
                            let hourStr = hour.toString().padStart(2, '0');

                            // 원하는 형식으로 날짜와 시간 문자열 생성
                            let date = `${year}년 ${month}월 ${day}일`;
                            let time = `${hourStr}:${min} ${period}`;


                            const result = `${name}, [${congestText}, ${congestionPercentage}명/100m²], ${dateStr}`;
                            
                            $("#loc_main").text(buildingName);

                            console.log(buildingName);

                            // 측정된 시간을 화면에 표시
                            console.log(date);  
                            $('#server_date').text(date);
                            $('#server_time').text(time);
                            $('#density_stage').text(congestText);
                        } else {
                            console.log(`해당 위치는 실시간 장소 혼잡도를 지원하고 있지 않습니다.`);
                        }
                    }
                    else {

                    }
                },
                error: function(request, status, error) {
                    console.log("code:" + request.status + "\nmessage:" + request.responseText + "\nerror:" + error);
                }
            });
        }

        function formatDate(datetime) {
            const year = datetime.substr(0, 4);
            const month = datetime.substr(4, 2);
            const day = datetime.substr(6, 2);
            let hour = parseInt(datetime.substr(8, 2));
            const min = datetime.substr(10, 2);
            const period = hour >= 12 ? "PM" : "AM";

            if (hour > 12) hour -= 12;
            if (hour === 0) hour = 12;

            return `${year}년 ${month}월 ${day}일 ${hour}:${min} ${period}`;
        }

        function congestionLevelText(congestionLevel) {
            switch (congestionLevel) {
                case 1: return "여유";
                case 2: return "보통";
                case 3: return "혼잡";
                case 4: return "매우 혼잡";
                default: return "알 수 없음";
            }
        }
    </script>
</body>
</html>

